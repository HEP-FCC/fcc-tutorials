

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2.5. Tracking and vertexing example using specific flavour decays &mdash; FCC Tutorials  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom-admonitions.css?v=e6bfab01" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="2.6. FCCAnalyses: Common problems and solutions" href="../FCCAnalysesProblemsAndSolutions.html" />
    <link rel="prev" title="2.4. FCC: Analysing simulated events" href="../fccanalyses/doc/starterkit/FccFastSimAnalysis/Readme.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            FCC Tutorials
              <img src="../../_static/fcc-logo-light.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../software-basics/README.html">1. First Steps</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../README.html">2. Generators, Fast Simulation and Analysis</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../FccFastSimGeneration.html">2.1. FCC: Getting started with event generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../k4simdelphes/doc/starterkit/FccFastSimDelphes/Readme.html">2.2. FCC: Getting started with simulating events in Delphes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eedE.html">2.3. Understanding generated process: eedE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fccanalyses/doc/starterkit/FccFastSimAnalysis/Readme.html">2.4. FCC: Analysing simulated events</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.5. Tracking and vertexing example using specific flavour decays</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#getting-the-fccanalyses">2.5.1. Getting the FCCAnalyses</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-analyzers-to-the-fccanalyses">2.5.2. Adding analyzers to the FCCAnalyses</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#exercise">2.5.2.1. Exercise</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reconstruction-of-the-primary-vertex-and-of-primary-tracks">2.5.3. Reconstruction of the primary vertex and of primary tracks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#exercise-1">2.5.3.1. Exercise 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exercise-2">2.5.3.2. Exercise 2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exercise-3">2.5.3.3. Exercise 3</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exercise-4">2.5.3.4. Exercise 4</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reconstruction-of-displaced-vertices-in-an-exclusive-decay-chain">2.5.4. Reconstruction of displaced vertices in an exclusive decay chain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#analysis-of-tau-rightarrow-3-mu">2.5.5. Analysis of <span class="math notranslate nohighlight">\(\tau \rightarrow 3 \mu\)</span></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">2.5.5.1. Exercise 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">2.5.5.2. Exercise 2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">2.5.5.3. Exercise 3</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">2.5.5.4. Exercise 4</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exercise-5">2.5.5.5. Exercise 5</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exercise-6">2.5.5.6. Exercise 6</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../FCCAnalysesProblemsAndSolutions.html">2.6. FCCAnalyses: Common problems and solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../EventProduction.html">2.7. Central production of events</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../full-detector-simulations/README.html">3. Full Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../distributed-computing/README.html">4. Distributed computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developing-fcc-software/README.html">5. Developing FCCSW</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CONTRIBUTING.html">6. Contributing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">External links:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://fccsw.web.cern.ch/">FCC Software</a></li>
<li class="toctree-l1"><a class="reference external" href="https://fcc-ee-detector-full-sim.docs.cern.ch/">FCC-ee Detector Full Sim</a></li>
<li class="toctree-l1"><a class="reference external" href="https://hep-fcc.github.io/FCCAnalyses/">FCCAnalyses</a></li>
<li class="toctree-l1"><a class="reference external" href="https://hsf-training.github.io/analysis-essentials/">Analysis essentials</a></li>
<li class="toctree-l1"><a class="reference external" href="https://hep-fcc.github.io/glossary">FCC Software glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">FCC Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../README.html"><span class="section-number">2. </span>Generators, Fast Simulation and Analysis</a></li>
      <li class="breadcrumb-item active"><span class="section-number">2.5. </span>Tracking and vertexing example using specific flavour decays</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/HEP-FCC/fcc-tutorials/blob/main/fast-sim-and-analysis/FccFastSimVertexing/Readme.md" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="tracking-and-vertexing-example-using-specific-flavour-decays">
<h1><span class="section-number">2.5. </span>Tracking and vertexing example using specific flavour decays<a class="headerlink" href="#tracking-and-vertexing-example-using-specific-flavour-decays" title="Link to this heading"></a></h1>
<blockquote>
<div><p>Original authors: Emmanuel Francois Perez, Clement Helsens</p>
</div></blockquote>
<div class="objectives admonition">
<p class="admonition-title">Learning Objectives</p>
<p>This tutorial will teach you how to:</p>
<ul class="simple">
<li><p>fit some tracks to a common vertex in <strong>FCCAnalyses</strong>, reconstruct the
primary vertex and the primary tracks</p></li>
<li><p>retrieve the tracks corresponding to a specific flavour decay in
<strong>FCCAnalyses</strong></p></li>
<li><p>produce <strong>flat ntuples</strong> with observables of interest with <strong>FCCAnalyses</strong></p></li>
<li><p>build your own algorithm inside <strong>FCCAnalyses</strong></p></li>
</ul>
<p>For the vertex fitter, we make use of the code developed by Franco Bedeschi,
<a class="reference external" href="https://indico.cern.ch/event/1003610/contributions/4214579/attachments/2187815/3696958/Bedeschi_Vertexing_Feb2021.pdf">see this talk</a>.
The <a class="reference external" href="https://indico.cern.ch/event/1180976/contributions/4960968/attachments/2481467/4259924/Bedeschi_Vertexing_Jul2022.pdf">subsequent updates presented in July 2022</a> offer possibilities
for complex reconstructions, but they are not yet ready to use in the public
FCCAnalyses version (coming soon).</p>
<p>To reconstruct the primary vertex and the primary tracks, we follow the LCFI+
algorithm (T. Suehara, T. Tanabe), described in
<a class="reference external" href="https://arxiv.org/pdf/1506.08371.pdf">arXiv:1506.08371</a>.</p>
</div>
<section id="getting-the-fccanalyses">
<h2><span class="section-number">2.5.1. </span>Getting the FCCAnalyses<a class="headerlink" href="#getting-the-fccanalyses" title="Link to this heading"></a></h2>
<p>The FCCAnalyses framework is provided already compiled in the Key4hep stack,
however once the stack is released this version of the FCCAnalyses can’t be
updated anymore. If one wants to benefit from the changes in the upstream
FCCAnalyses, they need to compile the latest version of it. The compilation
process is quite streamlined and requires only few steps.</p>
<p>As a first step create a fork of the
<a class="reference external" href="https://github.com/HEP-FCC/FCCAnalyses">FCCAnalyses project</a> on GitHub. More
details about FCC Software development workflow can be found in
<a class="reference internal" href="../../developing-fcc-software/FccSoftwareGit.html#development-workflow"><span class="std std-ref">Development workflow</span></a>.</p>
<p>After a short while the forking should be done and you can download the
FCCAnalyses to your machine. Go inside the area that you have setup for this
tutorial (for example <code class="docutils literal notranslate"><span class="pre">mkdir</span> <span class="pre">vtx-tutorial</span></code>) and clone your FCCAnalyses
repository:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>vtx-tutorial
git<span class="w"> </span>clone<span class="w"> </span>--branch<span class="w"> </span>pre-edm4hep1<span class="w"> </span>https://github.com/&lt;your-github-handle&gt;/FCCAnalyses.git
</pre></div>
</div>
<p>Go inside the FCCAnalyses directory and run the building of the FCCAnalyses
with:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>FCCAnalyses
<span class="nb">source</span><span class="w"> </span>./setup.sh
fccanalysis<span class="w"> </span>build
</pre></div>
</div>
<div class="callout admonition">
<p class="admonition-title">Older EDM4hep version</p>
<p>In this tutorial we will use centrally produced datasets which use relatively
old EDM4hep version, therefore we will use special branch of FCCAnalyses which
can work with those datasets.</p>
</div>
<p>After the successful building of the FCCAnalyses you can return back to the
main directory:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>..
</pre></div>
</div>
<p>To check if you are using the locally build version of FCCAnalyses use</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>which<span class="w"> </span>fccanalysis
</pre></div>
</div>
<p>It should lead to executable in your local install directory.</p>
</section>
<section id="adding-analyzers-to-the-fccanalyses">
<h2><span class="section-number">2.5.2. </span>Adding analyzers to the FCCAnalyses<a class="headerlink" href="#adding-analyzers-to-the-fccanalyses" title="Link to this heading"></a></h2>
<p>In order to extend the number of the available FCCAnalyses analyzers (C++
functions or functors used in the <code class="docutils literal notranslate"><span class="pre">.Define()</span></code> and <code class="docutils literal notranslate"><span class="pre">.Filter</span></code> methods of the
ROOT RDataFrame) we can either provide them in the additional C++ header file(s)
or edit the source code of the FCCAnalyses analyzers library.</p>
<p>For a quick addition of a few analyzers the first method is recommended, however
since in this method the additional C++ header file(s) need to be JIT compiled
every time the analysis is run the start-up time of the analysis can become very
long.</p>
<p>To register the C++ header file with the additional analyzers in your
analysis use <code class="docutils literal notranslate"><span class="pre">includePaths</span></code> attribute of the analysis script:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">includePaths</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;analyzers.h&quot;</span><span class="p">]</span>
</pre></div>
</div>
<div class="callout admonition">
<p class="admonition-title">Include file location</p>
<p>The location of the include files needs to be relative to the analysis script.</p>
</div>
<p>The second method involves directly editing the source code located in the
<code class="docutils literal notranslate"><span class="pre">analyzers/dataframe</span></code> directory of FCCAnalyses and afterwards running
<code class="docutils literal notranslate"><span class="pre">fccanalysis</span> <span class="pre">build</span></code> command.</p>
<section id="exercise">
<h3><span class="section-number">2.5.2.1. </span>Exercise<a class="headerlink" href="#exercise" title="Link to this heading"></a></h3>
<p>Let’s add a dummy analyzer which extracts <span class="math notranslate nohighlight">\(x\)</span> component of the particle
momentum from the collection of reconstructed particles.</p>
<div class="solution toggle admonition">
<p class="admonition-title">Suggested solution</p>
<p>First, download the dummy FCCAnalyses script:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>https://fccsw.web.cern.ch/fccsw/tutorials/vtx-tutorial/dummy_analysis.py
</pre></div>
</div>
<p>Then create an include file with the text editor of your choice:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>vim<span class="w"> </span>analyzers.h
</pre></div>
</div>
<p>which contains the definition of the dummy analyzer (<a class="reference external" href="https://fccsw.web.cern.ch/fccsw/tutorials/vtx-tutorial/analyzers.h">complete <code class="docutils literal notranslate"><span class="pre">analyzers.h</span></code> of
the tutorial</a>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef FCCANA_ADDITIONAL_ANALYZERS_H</span>
<span class="cp">#define FCCANA_ADDITIONAL_ANALYZERS_H</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ROOT/RVec.hxx&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;edm4hep/ReconstructedParticleData.h&quot;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">FCCAnalyses</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="nn">VtxAna</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">rv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">ROOT</span><span class="o">::</span><span class="nn">VecOps</span><span class="p">;</span>

<span class="w">  </span><span class="n">rv</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dummy_analyzer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">rv</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">parts</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rv</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">parts</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">      </span><span class="n">output</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">parts</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">momentum</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* FCCANA_ADDITIONAL_ANALYZERS_H */</span>
</pre></div>
</div>
<p>Add (uncomment) <code class="docutils literal notranslate"><span class="pre">includePaths</span></code> attribute in your dummy analysis script and
register the dummy analyzer to the dataframe and its output column into the
branch list.</p>
<p>Lastly let’s verify if everything works as expected with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fccanalysis</span> <span class="n">run</span> <span class="n">dummy_analysis</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">test</span> <span class="o">--</span><span class="n">nevents</span> <span class="mi">10</span> <span class="o">--</span><span class="n">output</span> <span class="n">dummy_result</span><span class="o">.</span><span class="n">root</span>
</pre></div>
</div>
<p>The dummy analyzer takes as argument the collection named
<code class="docutils literal notranslate"><span class="pre">ReconstructedParticles</span></code>, which is a vector of EDM4Hep objects
<code class="docutils literal notranslate"><span class="pre">edm4hep::ReconstructedParticleData</span></code>
[<a class="reference external" href="https://edm4hep.web.cern.ch/classedm4hep_1_1_reconstructed_particle_data.html">see here</a>]
and creates (defines) new column <code class="docutils literal notranslate"><span class="pre">dummy_momentum_collection</span></code>, which is later
added to the list of output variables.</p>
</div>
</section>
</section>
<section id="reconstruction-of-the-primary-vertex-and-of-primary-tracks">
<h2><span class="section-number">2.5.3. </span>Reconstruction of the primary vertex and of primary tracks<a class="headerlink" href="#reconstruction-of-the-primary-vertex-and-of-primary-tracks" title="Link to this heading"></a></h2>
<p>Let’s start by running primary vertex reconstruction on a few events of one
test file:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>https://fccsw.web.cern.ch/fccsw/tutorials/vtx-tutorial/analysis_primary_vertex.py
fccanalysis<span class="w"> </span>run<span class="w"> </span>analysis_primary_vertex.py<span class="w"> </span>--test<span class="w"> </span>--nevents<span class="w"> </span><span class="m">1000</span><span class="w"> </span>--output<span class="w"> </span>primary_Zuds.root
</pre></div>
</div>
<p>Note: with the option <code class="docutils literal notranslate"><span class="pre">--test</span></code>, we process the file that is hard-coded in the
attribute <code class="docutils literal notranslate"><span class="pre">testFile</span></code> inside of the <code class="docutils literal notranslate"><span class="pre">analysis_primary_vertex.py</span></code> script. In this
case, it is a file of <span class="math notranslate nohighlight">\(Z \rightarrow q \bar{q}\)</span> with <span class="math notranslate nohighlight">\(q=u,d,s\)</span>.</p>
<p>The resulting ntuple <code class="docutils literal notranslate"><span class="pre">primary_Zuds.root</span></code> contains the MC event vertex
<code class="docutils literal notranslate"><span class="pre">MC_PrimaryVertex</span></code>, and the reconstructed primary vertex <code class="docutils literal notranslate"><span class="pre">PrimaryVertex</span></code>.</p>
<div class="callout toggle admonition">
<p class="admonition-title">Snippet of <code class="docutils literal notranslate"><span class="pre">analysis_primary_vertex.py</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># MC event primary vertex</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;MC_PrimaryVertex&quot;</span><span class="p">,</span>
            <span class="s2">&quot;FCCAnalyses::MCParticle::get_EventPrimaryVertex(21)(Particle)&quot;</span><span class="p">)</span>

    <span class="c1"># Number of tracks</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;ntracks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ReconstructedParticle2Track::getTK_n(EFlowTrack_1)&quot;</span><span class="p">)</span>

    <span class="c1"># Fit all tracks of the events to a common vertex --- here using a</span>
    <span class="c1"># beam-spot constraint:</span>

    <span class="c1"># VertexObject_allTracks is an object of type `VertexingUtils::FCCAnalysesVertex`</span>
    <span class="c1"># It contains in particular:</span>
    <span class="c1">#   - an `edm4hep::VertexData`:</span>
    <span class="c1">#     - std::int32_t primary{}; ///&lt; boolean flag, if vertex is the primary vertex of the event</span>
    <span class="c1">#     - float chi2{}; ///&lt; chi-squared of the vertex fit</span>
    <span class="c1">#     - edm4hep::Vector3f position{}; ///&lt; [mm] position of the vertex.</span>
    <span class="c1">#     - std::array&lt;float, 6&gt; covMatrix{}; ///&lt; covariance matrix of the position (stored as lower triangle matrix, i.e. cov(xx),cov(y,x),cov(z,x),cov(y,y),...)</span>
    <span class="c1">#   - `ROOT::VecOps::RVec&lt;float&gt; reco_chi2`: the contribution to</span>
    <span class="c1">#     the chi2 of all tracks used in the fit</span>
    <span class="c1">#   - `ROOT::VecOps::RVec&lt;TVector3&gt; updated_track_momentum_at_vertex`:</span>
    <span class="c1">#     the post-fit (px, py, pz ) of the tracks, at the vertex</span>
    <span class="c1">#     (and not at their d.c.a.)</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;VertexObject_allTracks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;VertexFitterSimple::VertexFitter_Tk(1, EFlowTrack_1, true, 4.5, 20e-3, 300)&quot;</span><span class="p">)</span>

    <span class="c1"># `EFlowTrack_1` is the collection of all tracks (the fitting</span>
    <span class="c1"># method can of course be applied to a subset of tracks</span>
    <span class="c1"># (see later)).</span>
    <span class="c1"># &quot;true&quot; means that a beam-spot constraint is applied. Default is</span>
    <span class="c1"># no BSC. Following args are the BS size and position, in mum:</span>
    <span class="c1">#   - bool BeamSpotConstraint = false,</span>
    <span class="c1">#   - double sigmax=0., double sigmay=0., double sigmaz=0.,</span>
    <span class="c1">#   - double bsc_x=0., double bsc_y=0., double bsc_z=0. );</span>

    <span class="c1"># This returns the `edm4hep::VertexData`:</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;Vertex_allTracks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;VertexingUtils::get_VertexData(VertexObject_allTracks)&quot;</span><span class="p">)</span>  <span class="c1"># primary vertex, in mm</span>

    <span class="c1"># This is not a good estimate of the primary vertex: even in a Z -&gt; uds event, there are displaced tracks (e.g. Ks, Lambdas), which would bias the fit.</span>
    <span class="c1"># Below, we determine the &quot;primary tracks&quot; using an iterative algorithm - cf LCFI+.</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;RecoedPrimaryTracks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;VertexFitterSimple::get_PrimaryTracks(EFlowTrack_1, true, 4.5, 20e-3, 300, 0., 0., 0.)&quot;</span><span class="p">)</span>

    <span class="c1"># Now we run again the vertex fit, but only on the primary tracks :</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;PrimaryVertexObject&quot;</span><span class="p">,</span>
            <span class="s2">&quot;VertexFitterSimple::VertexFitter_Tk(1, RecoedPrimaryTracks, true, 4.5, 20e-3, 300)&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;PrimaryVertex&quot;</span><span class="p">,</span>
            <span class="s2">&quot;VertexingUtils::get_VertexData(PrimaryVertexObject)&quot;</span><span class="p">)</span>

    <span class="c1"># It is often useful to retrieve the secondary (i.e. non-primary) tracks, for example to search for secondary vertices.</span>
    <span class="c1"># The method below simply &quot;subtracts&quot; the primary tracks from the full collection :</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;SecondaryTracks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;VertexFitterSimple::get_NonPrimaryTracks(EFlowTrack_1, RecoedPrimaryTracks)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>To produce example plots, run the ROOT plotting macro <code class="docutils literal notranslate"><span class="pre">plot_primary_vertex.C</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wget</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">fccsw</span><span class="o">.</span><span class="n">web</span><span class="o">.</span><span class="n">cern</span><span class="o">.</span><span class="n">ch</span><span class="o">/</span><span class="n">fccsw</span><span class="o">/</span><span class="n">tutorials</span><span class="o">/</span><span class="n">vtx</span><span class="o">-</span><span class="n">tutorial</span><span class="o">/</span><span class="n">plot_primary_vertex</span><span class="o">.</span><span class="n">C</span>
</pre></div>
</div>
<div class="solution toggle admonition">
<p class="admonition-title">Suggested answer</p>
<p>The command to run is</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>root<span class="w"> </span>-b<span class="w"> </span>-q<span class="w"> </span><span class="s1">&#39;plot_primary_vertex.C()&#39;</span>
</pre></div>
</div>
<p>and it will produce four plot files (two <code class="docutils literal notranslate"><span class="pre">.png</span></code> and two <code class="docutils literal notranslate"><span class="pre">.pdf</span></code>).</p>
</div>
<p>This produces normalized <span class="math notranslate nohighlight">\(\chi^2\)</span> of the primary vertex fit, the resolutions
in <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(z\)</span>, and the pulls of the fitted vertex position.</p>
<section id="exercise-1">
<h3><span class="section-number">2.5.3.1. </span>Exercise 1<a class="headerlink" href="#exercise-1" title="Link to this heading"></a></h3>
<p>Add the number of primary and secondary tracks into the ntuple using the
function <code class="docutils literal notranslate"><span class="pre">ReconstructedParticle2Track::getTK_n(ROOT::VecOps::RVec&lt;edm4hep::TrackState&gt;</span> <span class="pre">x)</span></code>,
see the definition
<a class="reference external" href="https://github.com/HEP-FCC/FCCAnalyses/blob/783b2afc8d3e6b64a6af0447834183dbf4f246b8/analyzers/dataframe/src/ReconstructedParticle2Track.cc#L541">here</a>.</p>
<div class="solution toggle admonition">
<p class="admonition-title">Suggested answer</p>
<p>Needed definitions to be added to the dataframe:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># Number of primary and secondary tracks:</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;n_RecoedPrimaryTracks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ReconstructedParticle2Track::getTK_n(RecoedPrimaryTracks)&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;n_SecondaryTracks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ReconstructedParticle2Track::getTK_n(SecondaryTracks)&quot;</span><span class="p">)</span>
    <span class="c1"># equivalent: (this is to show that a simple C++ statement can be</span>
    <span class="c1"># included in a &quot;.Define&quot;)</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;n_SecondaryTracks_v2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;return ntracks - n_RecoedPrimaryTracks;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and those are the collections which should be in the <code class="docutils literal notranslate"><span class="pre">branchList</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">branchList</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;MC_PrimaryVertex&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ntracks&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Vertex_allTracks&quot;</span><span class="p">,</span>
        <span class="s2">&quot;PrimaryVertex&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_RecoedPrimaryTracks&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_SecondaryTracks&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_SecondaryTracks_v2&quot;</span><span class="p">,</span>
    <span class="p">]</span>
</pre></div>
</div>
</div>
</section>
<section id="exercise-2">
<h3><span class="section-number">2.5.3.2. </span>Exercise 2<a class="headerlink" href="#exercise-2" title="Link to this heading"></a></h3>
<p>Add the total <span class="math notranslate nohighlight">\(p_{T}\)</span> that is carried by the primary tracks. This requires
some simple analysis code to be written (added to our <code class="docutils literal notranslate"><span class="pre">analyzers.h</span></code> file).
Then, the analysis script needs to be updated to include
<code class="docutils literal notranslate"><span class="pre">includePaths</span> <span class="pre">=</span> <span class="pre">[&quot;analyzers.h&quot;]</span></code> attribute.</p>
<div class="callout admonition">
<p class="admonition-title">Hint</p>
<p>Take advantage of already provided <code class="docutils literal notranslate"><span class="pre">updated_track_momentum_at_vertex</span></code> member
of the <code class="docutils literal notranslate"><span class="pre">VertexingUtils::FCCAnalysesVertex</span></code> class (contains <code class="docutils literal notranslate"><span class="pre">TVector3</span></code> for each
track used in the vertex fit) and use function signature like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">sum_momentum_tracks</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">VertexingUtils</span><span class="o">::</span><span class="n">FCCAnalysesVertex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vertex</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="solution toggle admonition">
<p class="admonition-title">Suggested answer</p>
<p>Into the <code class="docutils literal notranslate"><span class="pre">analyzers.h</span></code> add</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;FCCAnalyses/VertexingUtils.h&quot;</span>
<span class="p">...</span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">sum_momentum_tracks</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">VertexingUtils</span><span class="o">::</span><span class="n">FCCAnalysesVertex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vertex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">TVector3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">momenta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vertex</span><span class="p">.</span><span class="n">updated_track_momentum_at_vertex</span><span class="p">;</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="n">momenta</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">py</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">px</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">py</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">       </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pt</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Do not forget to edit your <code class="docutils literal notranslate"><span class="pre">analysis_primary_vertex.py</span></code> and add the attribute
to the top:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">includePaths</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;analyzers.h&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>and also create the dataframe variable inside of <code class="docutils literal notranslate"><span class="pre">analyser()</span></code> method and
register it for saving in the <code class="docutils literal notranslate"><span class="pre">branchList</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>            <span class="o">...</span>
            <span class="c1"># Total pT carried by the primary tracks:</span>
            <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;sum_pt_primaries&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;VtxAna::sum_momentum_tracks( PrimaryVertexObject )&quot;</span><span class="p">)</span>
            <span class="o">...</span>

        <span class="o">...</span>
        <span class="n">branchList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="o">...</span>
            <span class="s2">&quot;sum_pt_primaries&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="o">...</span>
</pre></div>
</div>
</div>
</section>
<section id="exercise-3">
<h3><span class="section-number">2.5.3.3. </span>Exercise 3<a class="headerlink" href="#exercise-3" title="Link to this heading"></a></h3>
<p>Compare these distributions in <span class="math notranslate nohighlight">\(Z \rightarrow uds\)</span> events and in
<span class="math notranslate nohighlight">\(Z \rightarrow b\bar{b}\)</span> events.</p>
<div class="solution toggle admonition">
<p class="admonition-title">Suggested answer</p>
<p>Search the analysis script <code class="docutils literal notranslate"><span class="pre">analysis_primary_vertex.py</span></code> for the <code class="docutils literal notranslate"><span class="pre">testFile</span></code>
attribute and replace the <code class="docutils literal notranslate"><span class="pre">Zuds</span></code> file by the <code class="docutils literal notranslate"><span class="pre">Zbb</span></code> file (currently commented
out).</p>
</div>
</section>
<section id="exercise-4">
<h3><span class="section-number">2.5.3.4. </span>Exercise 4<a class="headerlink" href="#exercise-4" title="Link to this heading"></a></h3>
<blockquote>
<div><p><strong>Exercise to go beyond</strong></p>
</div></blockquote>
<p>The reconstruction of all secondary vertices following the LCFI+ algorithm has
been implemented in <strong>FCCAnalyses</strong> by Kunal Gautam and Armin Ilg in the pull
request <a class="reference external" href="https://github.com/HEP-FCC/FCCAnalyses/pull/206">PR#206</a>. It contains
example analysis script <code class="docutils literal notranslate"><span class="pre">examples/FCCee/vertex_lcfiplus/analysis_SV.py</span></code> which:</p>
<ul class="simple">
<li><p>reconstructs the primary vertex and primary tracks as done above</p></li>
<li><p>reconstructs jets using the Durham algorithm</p></li>
<li><p>reconstructs secondary vertices within all jets, and determines some
properties of these secondary vertices
It is also possible to reconstruct all secondary vertices in an event, without
reconstructing jets.</p></li>
</ul>
</section>
</section>
<section id="reconstruction-of-displaced-vertices-in-an-exclusive-decay-chain">
<h2><span class="section-number">2.5.4. </span>Reconstruction of displaced vertices in an exclusive decay chain<a class="headerlink" href="#reconstruction-of-displaced-vertices-in-an-exclusive-decay-chain" title="Link to this heading"></a></h2>
<p>We consider here <span class="math notranslate nohighlight">\(Z \rightarrow b \bar{b}\)</span> events. When a <span class="math notranslate nohighlight">\(B_s\)</span> is produced,
it is forced to decay into <span class="math notranslate nohighlight">\(J/\Psi \Phi\)</span> with <span class="math notranslate nohighlight">\(J/\Psi \rightarrow \mu^+\mu^-\)</span>
and <span class="math notranslate nohighlight">\(\Phi \rightarrow K^+ K^-\)</span>. We want to reconstruct the <span class="math notranslate nohighlight">\(B_s\)</span> decay vertex
and determine the resolution on the position of this vertex. Here, we use the
MC-matching information to figure out which are the reconstructed tracks that
are matched to the <span class="math notranslate nohighlight">\(B_s\)</span> decay products, and we fit these tracks to a common
vertex. That means, we “seed” the vertex reconstruction using the MC-truth
information. Let’s run the following:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>https://fccsw.web.cern.ch/fccsw/tutorials/vtx-tutorial/analysis_Bs2JpsiPhi_MCseeded.py
fccanalysis<span class="w"> </span>run<span class="w"> </span>analysis_Bs2JpsiPhi_MCseeded.py<span class="w"> </span>--test<span class="w"> </span>--nevents<span class="w"> </span><span class="m">1000</span><span class="w"> </span>--output<span class="w"> </span>Bs2JpsiPhi_MCseeded.root
</pre></div>
</div>
<p>The ntuple <code class="docutils literal notranslate"><span class="pre">Bs2JpsiPhi_MCseeded.root</span></code> contains the MC decay vertex of the
<span class="math notranslate nohighlight">\(B_s\)</span>, and the reconstructed decay vertex.</p>
<div class="callout toggle admonition">
<p class="admonition-title">Snippet of <code class="docutils literal notranslate"><span class="pre">analysis_Bs2JpsiPhi_MCseeded.py</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># MC indices of the decay</span>
    <span class="c1"># Bs (PDG = 531) -&gt; mu+ (PDG = -13) mu- (PDG = 13) K+ (PDG = 321) K- (PDG = -321)</span>
    <span class="c1"># Retrieves a vector of integers which correspond to indices in the</span>
    <span class="c1"># Particle block</span>
    <span class="c1"># vector[0] = the mother, and then the daughters in the order</span>
    <span class="c1"># specified, i.e. here [1] = the mu+, [2] = the mu-, [3] = the K+,</span>
    <span class="c1"># [4] = the K-</span>
    <span class="c1">#</span>
    <span class="c1"># Boolean arguments:</span>
    <span class="c1">#   1st: `stableDaughters`, when set to true, the daughters specified</span>
    <span class="c1">#        in the list are looked for among the final, stable</span>
    <span class="c1">#        particles that come out from the mother, i.e. the decay</span>
    <span class="c1">#        tree is explored recursively if needed.</span>
    <span class="c1">#   2nd: `chargeConjugateMother`</span>
    <span class="c1">#   3rd: `chargeConjugateDaughters`</span>
    <span class="c1">#   4th: `inclusiveDecay`, when set to false, if a mother is found,</span>
    <span class="c1">#        that decays into the particles specified in the list plus</span>
    <span class="c1">#        other particle(s), this decay is not selected.</span>
    <span class="c1"># If the event contains more than one such decays, only the first</span>
    <span class="c1"># one is kept.</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;Bs2MuMuKK_indices&quot;</span><span class="p">,</span>
            <span class="s2">&quot;MCParticle::get_indices(531, {-13,13,321,-321}, true, true, true, false) (Particle, Particle1)&quot;</span><span class="p">)</span>

    <span class="c1"># select events for which the requested decay chain has been found:</span>
    <span class="o">.</span><span class="n">Filter</span><span class="p">(</span><span class="s2">&quot;Bs2MuMuKK_indices.size() &gt; 0&quot;</span><span class="p">)</span>

    <span class="c1"># the mu+ (MCParticle) that comes from the Bs decay :</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;MC_Muplus&quot;</span><span class="p">,</span> <span class="s2">&quot;return Particle.at(Bs2MuMuKK_indices[1]);&quot;</span><span class="p">)</span>
    <span class="c1"># Decay vertex (an `edm4hep::Vector3d`) of the Bs (MC) = production</span>
    <span class="c1"># vertex of the muplus:</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;BsMCDecayVertex&quot;</span><span class="p">,</span> <span class="s2">&quot;return MC_Muplus.vertex;&quot;</span><span class="p">)</span>

    <span class="c1"># Returns the RecoParticles associated with the four Bs decay products.</span>
    <span class="c1"># The size of this collection is always 4 provided that</span>
    <span class="c1"># Bs2MuMuKK_indices is not empty, possibly including &quot;dummy&quot;</span>
    <span class="c1"># particles in case one of the legs did not make a RecoParticle</span>
    <span class="c1"># (e.g. because it is outside the tracker acceptance). This is done</span>
    <span class="c1"># on purpose, in order to maintain the mapping with the indices ---</span>
    <span class="c1"># i.e. the 1st particle in the list BsRecoParticles is the mu+,</span>
    <span class="c1"># then the mu-, etc.</span>
    <span class="c1"># (selRP_matched_to_list ignores the unstable MC particles that are</span>
    <span class="c1"># in the input list of indices hence the mother particle, which is</span>
    <span class="c1"># the [0] element of the Bs2MuMuKK_indices vector).</span>
    <span class="c1">#</span>
    <span class="c1"># The matching between RecoParticles and MCParticles requires 4</span>
    <span class="c1"># collections. For more detail, see</span>
    <span class="c1"># https://github.com/HEP-FCC/FCCAnalyses/tree/master/examples/basics</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;BsRecoParticles&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ReconstructedParticle2MC::selRP_matched_to_list(Bs2MuMuKK_indices, MCRecoAssociations0, MCRecoAssociations1, ReconstructedParticles, Particle)&quot;</span><span class="p">)</span>

    <span class="c1"># the corresponding tracks --- here, dummy particles, if any, are</span>
    <span class="c1"># removed, i.e. one may have &lt; 4 tracks, e.g. if one muon or kaon</span>
    <span class="c1"># was emitted outside of the acceptance</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;BsTracks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ReconstructedParticle2Track::getRP2TRK(BsRecoParticles, EFlowTrack_1)&quot;</span><span class="p">)</span>

    <span class="c1"># number of tracks in this BsTracks collection (= the #tracks</span>
    <span class="c1"># used to reconstruct the Bs vertex)</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;n_BsTracks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ReconstructedParticle2Track::getTK_n(BsTracks)&quot;</span><span class="p">)</span>

    <span class="c1"># Fit the tracks to a common vertex. That would be a secondary</span>
    <span class="c1"># vertex, hence we put a &quot;2&quot; as the first argument of</span>
    <span class="c1"># VertexFitter_Tk: First the full object, of type</span>
    <span class="c1"># Vertexing::FCCAnalysesVertex</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;BsVertexObject&quot;</span><span class="p">,</span> <span class="s2">&quot;VertexFitterSimple::VertexFitter_Tk(2, BsTracks)&quot;</span><span class="p">)</span>
    <span class="c1"># from which we extract the edm4hep::VertexData object, which</span>
    <span class="c1"># contains the vertex position in mm</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;BsVertex&quot;</span><span class="p">,</span>
            <span class="s2">&quot;VertexingUtils::get_VertexData(BsVertexObject)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>When you run the root macro <code class="docutils literal notranslate"><span class="pre">plot_Bs2JsiPhi.C</span></code> it will produce various plots
showing the vertex <span class="math notranslate nohighlight">\(\chi^2\)</span>, the vertex resolutions and the pulls of the vertex
fit</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>https://fccsw.web.cern.ch/fccsw/tutorials/vtx-tutorial/plots_Bs2JsiPhi.C
root<span class="w"> </span>-b<span class="w"> </span>-q<span class="w"> </span><span class="s2">&quot;plot_Bs2JsiPhi.C()&quot;</span>
</pre></div>
</div>
</section>
<section id="analysis-of-tau-rightarrow-3-mu">
<h2><span class="section-number">2.5.5. </span>Analysis of <span class="math notranslate nohighlight">\(\tau \rightarrow 3 \mu\)</span><a class="headerlink" href="#analysis-of-tau-rightarrow-3-mu" title="Link to this heading"></a></h2>
<p>The analysis showcased in
<a class="reference internal" href="#reconstruction-of-displaced-vertices-in-an-exclusive-decay-chain"><span class="std std-ref">Reconstruction of displaced vertices in an exclusive decay chain</span></a>
is used as a stepping stone for the following set of exercises.</p>
<section id="id1">
<h3><span class="section-number">2.5.5.1. </span>Exercise 1<a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p>Start from the <code class="docutils literal notranslate"><span class="pre">analysis_Bs2JpsiPhi_MCseeded.py</span></code> analysis script and adapt it
to the decay of <span class="math notranslate nohighlight">\(\tau \rightarrow 3 \mu\)</span>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cp<span class="w"> </span>analysis_Bs2JpsiPhi_MCseeded.py<span class="w"> </span>analysis_Tau3Mu_MCseeded.py

<span class="c1"># or</span>

wget<span class="w"> </span>https://fccsw.web.cern.ch/fccsw/tutorials/vtx-tutorial/analysis_Bs2JpsiPhi_MCseeded.py<span class="w"> </span>-O<span class="w"> </span>analysis_Tau3Mu_MCseeded.py
</pre></div>
</div>
<p>change the <code class="docutils literal notranslate"><span class="pre">testFile</span></code> to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">testFile</span> <span class="o">=</span> <span class="s2">&quot;/eos/experiment/fcc/ee/generation/DelphesEvents/spring2021/IDEA/p8_noBES_ee_Ztautau_ecm91_EvtGen_TauMinus2MuMuMu/events_189205650.root&quot;</span>
</pre></div>
</div>
<p>Modify the call to <code class="docutils literal notranslate"><span class="pre">MCParticle::get_indices</span></code> to retrieve properly the
indices of the decay of interest. Subsequently rename the <code class="docutils literal notranslate"><span class="pre">Bs2MuMuKK_indices</span></code>
into the name you chose — and, to have meaningful variable names, rename
<code class="docutils literal notranslate"><span class="pre">Bsxxx</span></code> into <code class="docutils literal notranslate"><span class="pre">Tauxxx</span></code>.</p>
<div class="solution toggle admonition">
<p class="admonition-title">Suggested answer</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;Tau3Mu_indices&quot;</span><span class="p">,</span>
            <span class="s2">&quot;MCParticle::get_indices(15, {-13, 13, 13}, true, true, true, false) (Particle, Particle1)&quot;</span> <span class="p">)</span>
</pre></div>
</div>
<p>The full file can be download from
<a class="reference external" href="https://fccsw.web.cern.ch/fccsw/tutorials/vtx-tutorial/analysis_Tau3Mu_MCseeded_start.py">here</a>.</p>
</div>
</section>
<section id="id2">
<h3><span class="section-number">2.5.5.2. </span>Exercise 2<a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<p>Add the reconstructed <span class="math notranslate nohighlight">\(\tau\)</span> mass to the ntuple (you will need to write new
code). Check that the mass resolution is improved when it is determined from
the track momenta <strong>at the tau decay vertex</strong>, compared to a blunt 3-muon mass
determined from the default track momenta (taken at the distance of closest
approach).</p>
<p><strong>Suggested implementation:</strong> analyzers with the following signatures need to be
added to your analyzers header file <code class="docutils literal notranslate"><span class="pre">analyzers_Tau3Mu.h</span></code> (created by copying
the <code class="docutils literal notranslate"><span class="pre">analyzers.h</span></code> from previous section):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">tau3mu_vertex_mass</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">VertexingUtils</span><span class="o">::</span><span class="n">FCCAnalysesVertex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vertex</span><span class="p">);</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">tau3mu_raw_mass</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">legs</span><span class="p">);</span>
</pre></div>
</div>
<div class="solution toggle admonition">
<p class="admonition-title">Suggested answer</p>
<p>Here is a possible implementation of the suggested functions, to be added to
the <code class="docutils literal notranslate"><span class="pre">analyzers_Tau3Mu.h</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[...]</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;TLorentzVector.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;edm4hep/ReconstructedParticleData.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;FCCAnalyses/VertexingUtils.h&quot;</span>

<span class="p">[...]</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">MUON_MASS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1056</span><span class="p">;</span><span class="w">  </span><span class="c1">// GeV</span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">tau3mu_vertex_mass</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">VertexingUtils</span><span class="o">::</span><span class="n">FCCAnalysesVertex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vertex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">TLorentzVector</span><span class="w"> </span><span class="n">tau</span><span class="p">;</span>
<span class="w">    </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">TVector3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">momenta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vertex</span><span class="p">.</span><span class="n">updated_track_momentum_at_vertex</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">momenta</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ileg</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ileg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">ileg</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">TVector3</span><span class="w"> </span><span class="n">track_momentum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">momenta</span><span class="p">[</span><span class="n">ileg</span><span class="p">];</span>
<span class="w">      </span><span class="n">TLorentzVector</span><span class="w"> </span><span class="n">leg</span><span class="p">;</span>
<span class="w">      </span><span class="n">leg</span><span class="p">.</span><span class="n">SetXYZM</span><span class="p">(</span><span class="n">track_momentum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">track_momentum</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">track_momentum</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">MUON_MASS</span><span class="p">);</span>
<span class="w">      </span><span class="n">tau</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">leg</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tau</span><span class="p">.</span><span class="n">M</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">tau3mu_raw_mass</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">legs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">TLorentzVector</span><span class="w"> </span><span class="n">tau</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">legs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ileg</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ileg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">ileg</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">TLorentzVector</span><span class="w"> </span><span class="n">leg</span><span class="p">;</span>
<span class="w">      </span><span class="n">leg</span><span class="p">.</span><span class="n">SetXYZM</span><span class="p">(</span><span class="n">legs</span><span class="p">[</span><span class="n">ileg</span><span class="p">].</span><span class="n">momentum</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">legs</span><span class="p">[</span><span class="n">ileg</span><span class="p">].</span><span class="n">momentum</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">legs</span><span class="p">[</span><span class="n">ileg</span><span class="p">].</span><span class="n">momentum</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">MUON_MASS</span><span class="p">);</span>
<span class="w">      </span><span class="n">tau</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">leg</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tau</span><span class="p">.</span><span class="n">M</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Add the call to your analysis file, i.e.: <code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu_MCseeded.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># The reco&#39;ed tau mass --- from the post-VertxFit momenta, at the tau decay</span>
    <span class="c1"># vertex:</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;TauMass&quot;</span><span class="p">,</span> <span class="s2">&quot;VtxAna::tau3mu_vertex_mass(TauVertexObject)&quot;</span><span class="p">)</span>
    <span class="c1"># The &quot;raw&quot; mass - using the track  momenta at their dca:</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;RawMass&quot;</span><span class="p">,</span> <span class="s2">&quot;VtxAna::tau3mu_raw_mass(TauRecoParticles)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and add the new variables to the list of branches <code class="docutils literal notranslate"><span class="pre">branchList</span></code> as usual.</p>
<p>Moreover, in order to be able to run the local code from <code class="docutils literal notranslate"><span class="pre">analyzers.h</span></code>, don’t
forget to add:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">includePaths</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;analyzers_Tau3Mu.h&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>to the beginning of the analysis script.</p>
<p>Run the <code class="docutils literal notranslate"><span class="pre">fccanalysis</span></code> command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>fccanalysis<span class="w"> </span>run<span class="w"> </span>analysis_Tau3Mu_MCseeded.py<span class="w"> </span>--test<span class="w"> </span>--nevents<span class="w"> </span><span class="m">1000</span><span class="w"> </span>--output<span class="w"> </span>Tau3Mu_MCseeded.root
</pre></div>
</div>
<p>Plot the mass distributions using ROOT. Launch the ROOT interpreter with</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>root<span class="w"> </span>-b<span class="w"> </span>Tau3Mu_MCseeded.root
</pre></div>
</div>
<p>and execute the following commands in the ROOT REPL:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TH1F</span><span class="o">*</span><span class="w"> </span><span class="n">h1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;h1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;;Tau Mass (GeV); a.u.&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mf">1.75</span><span class="p">,</span><span class="w"> </span><span class="mf">1.8</span><span class="p">);</span>
<span class="n">events</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;TauMass &gt;&gt; h1&quot;</span><span class="p">);</span>
<span class="n">TH1F</span><span class="o">*</span><span class="w"> </span><span class="n">h2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">TH1F</span><span class="p">(</span><span class="s">&quot;h2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;;Raw Mass (GeV); a.u.&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mf">1.75</span><span class="p">,</span><span class="w"> </span><span class="mf">1.8</span><span class="p">);</span>
<span class="n">events</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;RawMass &gt;&gt; h2&quot;</span><span class="p">);</span>
<span class="n">h1</span><span class="o">-&gt;</span><span class="n">SetLineColor</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="n">TCanvas</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">TCanvas</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">);</span>
<span class="n">h1</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;hist&quot;</span><span class="p">);</span>
<span class="n">h2</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;same, hist&quot;</span><span class="p">);</span>
<span class="n">c</span><span class="o">-&gt;</span><span class="n">Print</span><span class="p">(</span><span class="s">&quot;tau_mass.png&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</section>
<section id="id3">
<h3><span class="section-number">2.5.5.3. </span>Exercise 3<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>So far, everything was done using “Monte-Carlo seeding”, which gives the
resolutions that we expect, in the absence of possible combinatoric issues.
The next step is to write a new analysis script which starts from th
reconstructed muons.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cp<span class="w"> </span>analysis_Tau3Mu_MCseeded.py<span class="w">  </span>analysis_Tau3Mu.py
</pre></div>
</div>
<p>and keep only the skeleton of the <code class="docutils literal notranslate"><span class="pre">analysers()</span></code> method such that you delete all
of the defines and aliases, the result should look something like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RDFanalysis</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">analysers</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
        <span class="n">df2</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">df2</span>
</pre></div>
</div>
<p>Clear out also the <code class="docutils literal notranslate"><span class="pre">branchList</span></code>, and insert new defines into the <code class="docutils literal notranslate"><span class="pre">analysers()</span></code>
method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># Use the &quot;AllMuons&quot; collection, which contains also non-isolated muons (in</span>
    <span class="c1"># contrast to the &quot;Muons&quot; collection)</span>
    <span class="c1">#</span>
    <span class="c1"># Actually, &quot;Muon&quot; or (&quot;AllMuon&quot;) just contain pointers (indices) to the</span>
    <span class="c1"># RecoParticle collections, hence one needs to first retrieve the</span>
    <span class="c1"># RecoParticles corresponding to these muons (for more detail about the</span>
    <span class="c1"># subset collections, see:</span>
    <span class="c1"># https://github.com/HEP-FCC/FCCAnalyses/tree/master/examples/basics)</span>
    <span class="o">.</span><span class="n">Alias</span><span class="p">(</span><span class="s2">&quot;Muon0&quot;</span><span class="p">,</span> <span class="s2">&quot;AllMuon#0.index&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;muons&quot;</span><span class="p">,</span> <span class="s2">&quot;ReconstructedParticle::get(Muon0, ReconstructedParticles)&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;n_muons&quot;</span><span class="p">,</span> <span class="s2">&quot;ReconstructedParticle::get_n(muons)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We now want to write a method that builds muon triplets — actually, since the
MC files produced for this tutorial only forced the decay of the <span class="math notranslate nohighlight">\(\tau^-\)</span>, we
are interested in triplets with total charge equal to -1.</p>
<p><strong>Sub-exercise 1:</strong> create a function in your <code class="docutils literal notranslate"><span class="pre">analyzers_Tau3Mu.h</span></code> that builds
such triplet.</p>
<div class="callout admonition">
<p class="admonition-title">Hint</p>
<p>The function should take as an input the collection of muons (subset collection
of reconstructed particles) and the charge of the triplet, and should return a
vector of vectors with all combinations of 3-muons. Its signature should look
something like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&gt;</span>
<span class="n">build_triplets</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inParticles</span><span class="p">,</span>
<span class="w">               </span><span class="kt">float</span><span class="w"> </span><span class="n">total_charge</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="solution toggle admonition">
<p class="admonition-title">Suggested answer</p>
<p>Here is the example implementation of the <code class="docutils literal notranslate"><span class="pre">build_triplets()</span></code> function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&gt;</span>
<span class="w">  </span><span class="n">build_triplets</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inParticles</span><span class="p">,</span>
<span class="w">                 </span><span class="kt">float</span><span class="w"> </span><span class="n">total_charge</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inParticles</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inParticles</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="w"> </span><span class="n">pj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inParticles</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="w"> </span><span class="n">pk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inParticles</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="w">          </span><span class="kt">float</span><span class="w"> </span><span class="n">charge_tot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi</span><span class="p">.</span><span class="n">charge</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pj</span><span class="p">.</span><span class="n">charge</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pk</span><span class="p">.</span><span class="n">charge</span><span class="p">;</span>

<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">charge_tot</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">total_charge</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a_triplet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="n">pj</span><span class="p">,</span><span class="w"> </span><span class="n">pk</span><span class="p">};</span>
<span class="w">            </span><span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a_triplet</span><span class="p">);</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span><span class="w">  </span><span class="c1">// end of the loop over k</span>
<span class="w">      </span><span class="p">}</span><span class="w">  </span><span class="c1">// end of the loop over j</span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span><span class="c1">// end of the loop over i</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>You can then use it in your <code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># Build triplets of muons.</span>
    <span class="c1"># We are interested in tau- -&gt; mu- mu- mu+ (the MC files produced</span>
    <span class="c1"># for this tutorial only forced the decay of the tau- , not the</span>
    <span class="c1"># tau+). Hence we look for triples of total charge = -1:</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;triplets_m&quot;</span><span class="p">,</span> <span class="s2">&quot;VtxAna::build_triplets(muons, -1.)&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;n_triplets_m&quot;</span><span class="p">,</span> <span class="s2">&quot;return triplets_m.size();&quot;</span><span class="p">)</span>

</pre></div>
</div>
<p><strong>NB:</strong> the efficiency for having the three muons from the tau decay that fall
within the tracker acceptance is about 95%. However, a track will reach the
muon detector only if its momentum is larger than about 2 GeV (in Delphes, the
efficiency for muons below 2 GeV is set to zero). When adding the requirement
that the three muons have <span class="math notranslate nohighlight">\(p &gt; 2 GeV\)</span>, the efficiency drops to about 75%. You
can check that using the MC information, starting e.g. from
<code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu_MCseeded.py</span></code>. Consequently: out of 1000 signal events, a
triplet is found only in roughly 750 events.</p>
<p>It is then simple to build a tau candidate from the first triplet that has been
found, e.g.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># ----------------------------------------------------</span>
<span class="c1">#    # Considering only the 1st triplet:</span>
<span class="c1">#    .Define(&quot;the_muons_candidate_0&quot;,</span>
<span class="c1">#            &quot;return triplets_m[0];&quot;)  # the_muons_candidates = a vector of 3 RecoParticles</span>
<span class="c1">#    # get the corresponding tracks:</span>
<span class="c1">#    .Define(&quot;the_muontracks_candidate_0&quot;,</span>
<span class="c1">#            &quot;ReconstructedParticle2Track::getRP2TRK(the_muons_candidate_0, EFlowTrack_1)&quot;)</span>
<span class="c1">#    # and fit them to a common vertex:</span>
<span class="c1">#    .Define(&quot;TauVertexObject_candidate_0&quot;,</span>
<span class="c1">#            &quot;VertexFitterSimple::VertexFitter_Tk(2, the_muontracks_candidate_0)&quot;)</span>
<span class="c1">#    # Now we can get the mass of this candidate, as before:</span>
<span class="c1">#    .Define(&quot;TauMass_candidate_0&quot;,</span>
<span class="c1">#            &quot;myAnalysis::tau3mu_vertex_mass( TauVertexObject_candidate_0)&quot;)</span>
</pre></div>
</div>
<p>but we would like to retrieve all tau candidates and decide later which one to use.</p>
</div>
<p><strong>Sub-exercise 2</strong>: create a function in your <code class="docutils literal notranslate"><span class="pre">analyzers_Tau3Mu.h</span></code> to retrieve all tau
candidates, and their corresponding tau mass.</p>
<div class="callout admonition">
<p class="admonition-title">Hint</p>
<p>The functions could have the following signatures (to be added to <code class="docutils literal notranslate"><span class="pre">analyzers_Tau3Mu.h</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">VertexingUtils</span><span class="o">::</span><span class="n">FCCAnalysesVertex</span><span class="o">&gt;</span>
<span class="n">build_AllTauVertexObject</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">triplets</span><span class="p">,</span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">TrackState</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">allTracks</span><span class="p">);</span>

<span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>
<span class="n">build_AllTauMasses</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">VertexingUtils</span><span class="o">::</span><span class="n">FCCAnalysesVertex</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vertices</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="solution toggle admonition">
<p class="admonition-title">Suggested answer</p>
<p>This are example implementations to be added to your <code class="docutils literal notranslate"><span class="pre">analyzers_Tau3Mu.h</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">VertexingUtils</span><span class="o">::</span><span class="n">FCCAnalysesVertex</span><span class="o">&gt;</span>
<span class="n">build_AllTauVertexObject</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">triplets</span><span class="p">,</span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">TrackState</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">allTracks</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="w"> </span><span class="n">VertexingUtils</span><span class="o">::</span><span class="n">FCCAnalysesVertex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">results</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ntriplets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">triplets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ntriplets</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">legs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">triplets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">    </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">TrackState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">the_tracks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ReconstructedParticle2Track</span><span class="o">::</span><span class="n">getRP2TRK</span><span class="p">(</span><span class="n">legs</span><span class="p">,</span><span class="w"> </span><span class="n">allTracks</span><span class="p">);</span>
<span class="w">    </span><span class="n">VertexingUtils</span><span class="o">::</span><span class="n">FCCAnalysesVertex</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VertexFitterSimple</span><span class="o">::</span><span class="n">VertexFitter_Tk</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">the_tracks</span><span class="p">);</span>
<span class="w">    </span><span class="n">results</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">results</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>
<span class="n">build_AllTauMasses</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">VertexingUtils</span><span class="o">::</span><span class="n">FCCAnalysesVertex</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vertices</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">results</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="n">vertices</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">mass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tau3mu_vertex_mass</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="n">results</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mass</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">results</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and these includes must be added as well:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;FCCAnalyses/ReconstructedParticle2Track.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;FCCAnalyses/VertexFitterSimple.h&quot;</span>
</pre></div>
</div>
<p>You can then use them in your analysis script like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>   <span class="c1"># ----------------------------------------------------</span>
   <span class="c1"># Now consider all triplets :</span>

   <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;TauVertexObject_allCandidates&quot;</span><span class="p">,</span>
           <span class="s2">&quot;VtxAna::build_AllTauVertexObject(triplets_m, EFlowTrack_1)&quot;</span><span class="p">)</span>
   <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;TauMass_allCandidates&quot;</span><span class="p">,</span>
           <span class="s2">&quot;VtxAna::build_AllTauMasses(TauVertexObject_allCandidates)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and you add the mass of all candidates into your branch output list:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">branchList</span> <span class="o">=</span> <span class="p">[</span>
                 <span class="s2">&quot;n_muons&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;n_triplets_m&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;TauMass_allCandidates&quot;</span>
                 <span class="p">]</span>
</pre></div>
</div>
<p>Run <code class="docutils literal notranslate"><span class="pre">fccanalysis</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>fccanalysis<span class="w"> </span>run<span class="w"> </span>analysis_Tau3Mu.py<span class="w"> </span>--test<span class="w"> </span>--nevents<span class="w"> </span><span class="m">1000</span><span class="w"> </span>--output<span class="w"> </span>Tau3Mu.root
</pre></div>
</div>
<p>and examine the result stored in the output ROOT file with <code class="docutils literal notranslate"><span class="pre">root</span> <span class="pre">-b</span> <span class="pre">Tau3Mu.root</span></code>
and the following ROOT REPL instructions:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TCanvas</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">TCanvas</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">);</span>
<span class="c1">// candidates at large mass pick up a muon from the &quot;other&quot; leg</span>
<span class="n">events</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;TauMass_allCandidates&quot;</span><span class="p">)</span>
<span class="c1">// the genuine tau to 3mu candidates</span>
<span class="n">events</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="s">&quot;TauMass_allCandidates&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;TauMass_allCandidates &lt; 2&quot;</span><span class="p">)</span>
<span class="n">c</span><span class="o">-&gt;</span><span class="n">Print</span><span class="p">(</span><span class="s">&quot;tau_mass.png&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</section>
<section id="id4">
<h3><span class="section-number">2.5.5.4. </span>Exercise 4<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<p>We now want to look at the background.
Create a new script file by copying your <code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu.py</span></code> into a new file:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cp<span class="w"> </span>analysis_Tau3Mu.py<span class="w"> </span>analysis_Tau3Mu_stage1.py
</pre></div>
</div>
<blockquote>
<div><p><strong>Note:</strong> The <code class="docutils literal notranslate"><span class="pre">_stage1</span></code> suffix indicates that it is a first step in the chain
of analysis scripts.</p>
</div></blockquote>
<p>The main background is expected to come from <span class="math notranslate nohighlight">\(\tau \rightarrow 3 \pi \nu\)</span>
decays, when the charged pions are misidentified as muons. But there is no
“fakes” in Delphes: all “Muon” objects that you have in the EDM4hep file
do originate from genuine muons (which may, of course, come from a hadron decay).
To alleviate this limitation, we first select the <code class="docutils literal notranslate"><span class="pre">ReconstructedParticle</span></code>s
that are matched to a stable, charged hadron. Edit your
<code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu_stage1.py</span></code> script file and add the following lines right
before the <code class="docutils literal notranslate"><span class="pre">.Define(&quot;n_muons&quot;,</span> <span class="pre">...</span> <span class="pre">)</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># -----------------------------------------</span>
    <span class="c1"># Add fake muons from pi -&gt; mu</span>
    <span class="c1"># This selects the charged hadrons:</span>
    <span class="o">.</span><span class="n">Alias</span><span class="p">(</span><span class="s2">&quot;MCRecoAssociations0&quot;</span><span class="p">,</span> <span class="s2">&quot;MCRecoAssociations#0.index&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Alias</span><span class="p">(</span><span class="s2">&quot;MCRecoAssociations1&quot;</span><span class="p">,</span> <span class="s2">&quot;MCRecoAssociations#1.index&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;ChargedHadrons&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ReconstructedParticle2MC::selRP_ChargedHadrons(MCRecoAssociations0, MCRecoAssociations1, ReconstructedParticles, Particle)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>(As mentioned earlier, the matching between reconstructed particles and Monte
Carlo particles requires 4 collections. See
<a class="reference external" href="https://github.com/HEP-FCC/FCCAnalyses/tree/master/examples/basics">here</a> for more detail).</p>
<p>and further select the ones that are above 2 GeV — since only particles above
2 GeV will make it to the muon detector:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># Only the ones with  p &gt; 2 GeV could be selected as muons:</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;ChargedHadrons_pgt2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ReconstructedParticle::sel_p(2.)(ChargedHadrons)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we want to apply a “flat” fake rate, i.e. accept a random fraction of the
above particles as muons.</p>
<p><strong>Exercise itself:</strong> create an analyzer (functor) in your <code class="docutils literal notranslate"><span class="pre">analyzers_Tau3Mu.h</span></code>
that does that.</p>
<div class="callout admonition">
<p class="admonition-title">Hint</p>
<p>In your header file <code class="docutils literal notranslate"><span class="pre">analyzers_Tau3Mu.h</span></code> you need to define a C++ struct and
add few includes, like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;random&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;chrono&gt;</span>

<span class="p">[...]</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">selRP_Fakes</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">selRP_Fakes</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">arg_fakeRate</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">arg_mass</span><span class="p">);</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">m_fakeRate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e-3</span><span class="p">;</span><span class="w">  </span><span class="c1">// fake rate</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">m_mass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MUON_MASS</span><span class="p">;</span><span class="w">  </span><span class="c1">// particle mass</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span><span class="w"> </span><span class="n">m_generator</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_flat</span><span class="p">;</span>

<span class="w">    </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">operator</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inParticles</span><span class="p">);</span>
<span class="w">  </span><span class="p">};</span>
</pre></div>
</div>
</div>
<div class="solution toggle admonition">
<p class="admonition-title">Suggested answer</p>
<p>The example implementation of the functor to be added into your
<code class="docutils literal notranslate"><span class="pre">analyzers_Tau3Mu.h</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">selRP_Fakes</span><span class="o">::</span><span class="n">selRP_Fakes</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">arg_fakeRate</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">arg_mass</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">m_fakeRate</span><span class="p">(</span><span class="n">arg_fakeRate</span><span class="p">),</span>
<span class="w">                                                                </span><span class="n">m_mass</span><span class="p">(</span><span class="n">arg_mass</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">().</span><span class="n">time_since_epoch</span><span class="p">().</span><span class="n">count</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span><span class="w"> </span><span class="nf">generator</span><span class="p">(</span><span class="n">seed</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_generator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generator</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">flatdis</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_flat</span><span class="p">.</span><span class="n">param</span><span class="p">(</span><span class="n">flatdis</span><span class="p">.</span><span class="n">param</span><span class="p">());</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">selRP_Fakes</span><span class="o">::</span><span class="k">operator</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inParticles</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ROOT</span><span class="o">::</span><span class="n">VecOps</span><span class="o">::</span><span class="n">RVec</span><span class="o">&lt;</span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="n">inParticles</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">float</span><span class="w"> </span><span class="n">arandom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_flat</span><span class="p">(</span><span class="n">m_generator</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arandom</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">m_fakeRate</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">edm4hep</span><span class="o">::</span><span class="n">ReconstructedParticleData</span><span class="w"> </span><span class="n">reso</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// overwrite the mass:</span>
<span class="w">        </span><span class="n">reso</span><span class="p">.</span><span class="n">mass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_mass</span><span class="p">;</span>
<span class="w">        </span><span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">reso</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>We then use this functor (analyzer) in the analysis script
<code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu_stage1.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># Build fake muons based on a flat fake rate (random selection) ---</span>
    <span class="c1"># HUGE fake rate used on purpose here:</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;fakeMuons_5em2&quot;</span><span class="p">,</span>
            <span class="n">ROOT</span><span class="o">.</span><span class="n">VtxAna</span><span class="o">.</span><span class="n">selRP_Fakes</span><span class="p">(</span><span class="mf">5e-2</span><span class="p">,</span> <span class="n">ROOT</span><span class="o">.</span><span class="n">VtxAna</span><span class="o">.</span><span class="n">MUON_MASS</span><span class="p">),</span>
            <span class="p">[</span><span class="s2">&quot;ChargedHadrons_pgt2&quot;</span><span class="p">])</span>
    <span class="c1"># Now we merge the collection of fake muons with the genuine muons:</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;muons_with_fakes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ReconstructedParticle::merge( muons, fakeMuons_5em2 )&quot;</span><span class="p">)</span>
    <span class="c1"># and we use this collection later on, instead of &quot;muons&quot;:</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;n_muons_with_fakes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ReconstructedParticle::get_n(muons_with_fakes)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and we just need to replace the muon collection when building the triplets:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># returns a vector of triplets, i.e. of vectors of 3 RecoParticles</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;triplets_m&quot;</span><span class="p">,</span> <span class="s2">&quot;myAnalysis::build_triplets(muons_with_fakes, -1.)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Moreover, in order to pass the functor constructor of <code class="docutils literal notranslate"><span class="pre">selRP_Fakes</span></code> as above
(<code class="docutils literal notranslate"><span class="pre">ROOT.myAnalysis.selRP_Fakes(5e-2,</span> <span class="pre">MUON_MASS)</span></code>, not inside a string), we need
to add</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ROOT</span>
</pre></div>
</div>
<p>at the top of our analysis script <code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu_stage1.py</span></code>.</p>
<p>You can also output the total visible energy into your ntuple:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># Total visible energy in the event:</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;RecoPartEnergies&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ReconstructedParticle::get_e(ReconstructedParticles)&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">Define</span><span class="p">(</span><span class="s2">&quot;visible_energy&quot;</span><span class="p">,</span> <span class="s2">&quot;Sum(RecoPartEnergies)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and add it to your <code class="docutils literal notranslate"><span class="pre">branchList</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">branchList</span> <span class="o">=</span> <span class="p">[</span>
        <span class="o">...</span>
        <span class="s2">&quot;n_muons&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_triplets_m&quot;</span><span class="p">,</span>
        <span class="s2">&quot;TauMass_allCandidates&quot;</span><span class="p">,</span>
        <span class="s2">&quot;visible_energy&quot;</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Run it again on the test signal file, in order to make sure that nothing is
broken:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>fccanalysis<span class="w"> </span>run<span class="w"> </span>analysis_Tau3Mu_stage1.py<span class="w"> </span>--test<span class="w"> </span>--nevents<span class="w"> </span><span class="m">1000</span><span class="w"> </span>--output<span class="w"> </span>Tau3Mu.root
</pre></div>
</div>
</div>
<p>The files <code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu_stage1.py</span></code> and <code class="docutils literal notranslate"><span class="pre">analyzers_Tau3Mu.h</span></code> with all the
changes discussed above can be downloaded
<a class="reference external" href="https://fccsw.web.cern.ch/fccsw/tutorials/vtx-tutorial/Exercises/analysis_Tau3Mu_stage1.py">here</a>
and
<a class="reference external" href="https://fccsw.web.cern.ch/fccsw/tutorials/vtx-tutorial/Exercises/analyzers_Tau3Mu.h">here</a>.</p>
</section>
<section id="exercise-5">
<h3><span class="section-number">2.5.5.5. </span>Exercise 5<a class="headerlink" href="#exercise-5" title="Link to this heading"></a></h3>
<p>We now have a simple analysis that can be used to process the signal and
background samples, and plot the mass of the <span class="math notranslate nohighlight">\(\tau \rightarrow 3\mu\)</span> candidates.
We can now process the full statistics. In order for you to have access
to the dataset metadata provided in the
<code class="docutils literal notranslate"><span class="pre">/afs/cern.ch/work/f/fccsw/public/FCCDicts/</span></code>, you need to have CERN computing
account and have the
<a class="reference external" href="https://resources-old.web.cern.ch/resources-old/Manage/AFS/Default.aspx">AFS Workspaces</a>
service activated.</p>
<p>All samples that have been centrally produced can be found
<a class="reference external" href="https://fcc-physics-events.web.cern.ch/FCCee/">on this web page</a>. We use
<code class="docutils literal notranslate"><span class="pre">spring2021</span></code> samples (in <code class="docutils literal notranslate"><span class="pre">campaign</span></code>), and the files made with <code class="docutils literal notranslate"><span class="pre">IDEA</span></code> detector
concept.
If you enter <code class="docutils literal notranslate"><span class="pre">TauMinus2MuMuMu</span></code> and <code class="docutils literal notranslate"><span class="pre">TauMinus2PiPiPinus</span></code> in the search field,
you will see the datasets produced for the signal and the
<span class="math notranslate nohighlight">\(\tau \rightarrow 3\pi \nu\)</span> background. The first column shows the dataset
names, in this case
<code class="docutils literal notranslate"><span class="pre">p8_noBES_ee_Ztautau_ecm91_EvtGen_TauMinus2MuMuMu</span></code> and
<code class="docutils literal notranslate"><span class="pre">p8_noBES_ee_Ztautau_ecm91_EvtGen_TauMinus2PiPiPinu</span></code>.</p>
<p>To run <code class="docutils literal notranslate"><span class="pre">fccanalysis</span></code> over these datasets (and not anymore over one test file),
the list of datasets to be processed should be inserted into your analysis
<code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu_stage1.py</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ROOT</span>

<span class="n">processList</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;p8_noBES_ee_Ztautau_ecm91_EvtGen_TauMinus2MuMuMu&#39;</span><span class="p">:</span> <span class="p">{},</span>
    <span class="s1">&#39;p8_noBES_ee_Ztautau_ecm91_EvtGen_TauMinus2PiPiPinu&#39;</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>as well as information where to look for the dataset metadata information</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Mandatory: Production tag when running over centrally produced events, this</span>
<span class="c1"># points to the yaml files for getting the dataset statistics</span>
<span class="n">prodTag</span> <span class="o">=</span> <span class="s2">&quot;FCCee/spring2021/IDEA/&quot;</span>
</pre></div>
</div>
<p>and we tell <code class="docutils literal notranslate"><span class="pre">fccanalysis</span></code> to put all files into the <code class="docutils literal notranslate"><span class="pre">Tau3Mu</span></code> directory:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Optional: output directory, default is local running directory</span>
<span class="n">outputDir</span> <span class="o">=</span> <span class="s2">&quot;Tau3Mu&quot;</span>
</pre></div>
</div>
<p>This produces flat ntuples:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>fccanalysis<span class="w"> </span>run<span class="w"> </span>analysis_Tau3Mu_stage1.py
</pre></div>
</div>
<p>After a few minutes, you will see two ntuples, one for the signal, the other
for the background, in the <code class="docutils literal notranslate"><span class="pre">Tau3Mu</span></code> directory.</p>
<p>Now that you have ntuples with the variables you need for your analysis, you
may analyze them using the tools you prefer. As explained
<a class="reference external" href="https://github.com/HEP-FCC/FCCAnalyses">here</a>, you can also use <code class="docutils literal notranslate"><span class="pre">fccanalysis</span></code>
to produce histograms of some variables, with some sets of cuts, and to plot
them. The normalisation is then taken care of by <code class="docutils literal notranslate"><span class="pre">fccanalyses</span></code>, thanks to a JSON
file (<code class="docutils literal notranslate"><span class="pre">FCCee_procDict_spring2021_IDEA.json</span></code>) which contains the cross-section
of the MC processes. To use these functionalities:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu_final.py</span></code> analysis script produces histograms of selected
variables, with some selection:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>https://fccsw.web.cern.ch/fccsw/tutorials/vtx-tutorial/analysis_Tau3Mu_final.py
fccanalysis<span class="w"> </span>final<span class="w"> </span>analysis_Tau3Mu_final.py
</pre></div>
</div>
<div class="callout toggle admonition">
<p class="admonition-title">Snippet of <code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu_final.py</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Dictionnay of the list of cuts. The key is the name of the selection that</span>
<span class="c1"># will be added to the output file</span>
<span class="n">cutList</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;nocut&quot;</span><span class="p">:</span> <span class="s2">&quot;true&quot;</span><span class="p">,</span>
           <span class="s2">&quot;sel0&quot;</span><span class="p">:</span> <span class="s2">&quot;n_triplets_m &gt; 0&quot;</span><span class="p">,</span>
           <span class="s2">&quot;sel1&quot;</span><span class="p">:</span> <span class="s2">&quot;Min(TauMass_allCandidates) &lt; 3&quot;</span>
<span class="p">}</span>


<span class="c1"># Dictionary for the output variables/hitograms. The key is the name of the</span>
<span class="c1"># variable in the output files. &quot;name&quot; is the name of the variable in the</span>
<span class="c1"># input file, &quot;title&quot; is the x-axis label of the histogram, &quot;bin&quot; the number</span>
<span class="c1"># of bins of the histogram, &quot;xmin&quot; the minimum x-axis value and &quot;xmax&quot; the</span>
<span class="c1"># maximum x-axis value.</span>
<span class="n">histoList</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;mTau&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;TauMass_allCandidates&quot;</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;m_</span><span class="si">{tau}</span><span class="s2"> [GeV]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bin&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;xmin&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;xmax&quot;</span><span class="p">:</span> <span class="mi">3</span>
    <span class="p">},</span>
    <span class="s2">&quot;mTau_zoom&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;TauMass_allCandidates&quot;</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;m_</span><span class="si">{tau}</span><span class="s2"> [GeV]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bin&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;xmin&quot;</span><span class="p">:</span> <span class="mf">1.7</span><span class="p">,</span>
        <span class="s2">&quot;xmax&quot;</span><span class="p">:</span> <span class="mf">1.9</span>
    <span class="p">},</span>
    <span class="s2">&quot;Evis&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;visible_energy&quot;</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;E_</span><span class="si">{vis}</span><span class="s2"> [GeV]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bin&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;xmin&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;xmax&quot;</span><span class="p">:</span> <span class="mf">91.2</span>
    <span class="p">},</span>
<span class="p">}</span>

</pre></div>
</div>
</div>
<p>This produces three histograms, for three sets of selections. The histogram
files appear in the <code class="docutils literal notranslate"><span class="pre">TauMu/final</span></code> directory. There are now 6 files (2 processes,
3 sets of cuts). The histograms are normalised to a luminosity of one inverse
pb.</p>
<p>Finally, the plotting script <code class="docutils literal notranslate"><span class="pre">analysis_Tau3Mu_plots.py</span></code> makes few plots:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>https://fccsw.web.cern.ch/fccsw/tutorials/vtx-tutorial/analysis_Tau3Mu_plots.py
fccanalysis<span class="w"> </span>plots<span class="w"> </span>analysis_Tau3Mu_plots.py
</pre></div>
</div>
<p>which appear in the <code class="docutils literal notranslate"><span class="pre">Tau3Mu/plots</span></code> directory. Look for example at the plot
<code class="docutils literal notranslate"><span class="pre">mTaTau3Mu_nostack_log</span></code> in <code class="docutils literal notranslate"><span class="pre">Tau3Mu/plots/sel1</span></code>. The candidates in the background
sample, corresponding to <span class="math notranslate nohighlight">\(\tau \rightarrow 3 \pi \nu\)</span> decays, are reconstructed
at a mass that is usually below the <span class="math notranslate nohighlight">\(\tau\)</span> mass due to the presence of the
neutrino. Note that the background sample corresponds to a very low statistics
(50M have been produced, we expect 14B) and we see fluctuations. The signal
cross-section used here corresponds to <span class="math notranslate nohighlight">\(B( \tau \rightarrow 3 \mu) = 2 \times
10^{-8}\)</span>, which is roughly the current upper limit. The luminosity for these
final plots is entered in analysis_Tau3Mu_plots.py.</p>
</section>
<section id="exercise-6">
<h3><span class="section-number">2.5.5.6. </span>Exercise 6<a class="headerlink" href="#exercise-6" title="Link to this heading"></a></h3>
<blockquote>
<div><p><strong>Exercise to go beyond</strong></p>
</div></blockquote>
<p><em>Interested in studying the FCC-ee sensitivity to <span class="math notranslate nohighlight">\(\tau \rightarrow 3 \mu\)</span>?</em><br />
Please contact
&lt;<a class="reference external" href="mailto:alberto&#46;lusiani&#37;&#52;&#48;pi&#46;infn&#46;it">alberto<span>&#46;</span>lusiani<span>&#64;</span>pi<span>&#46;</span>infn<span>&#46;</span>it</a>&gt; and
&lt;<a class="reference external" href="mailto:monteil&#37;&#52;&#48;in2p3&#46;fr">monteil<span>&#64;</span>in2p3<span>&#46;</span>fr</a>&gt;.</p>
<p>Note that the input files used in this tutorial are low statistics examples.
Larger datasets that are more accurate (KKMC instead of Pythia) can be produced
if someone is interested.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../fccanalyses/doc/starterkit/FccFastSimAnalysis/Readme.html" class="btn btn-neutral float-left" title="2.4. FCC: Analysing simulated events" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../FCCAnalysesProblemsAndSolutions.html" class="btn btn-neutral float-right" title="2.6. FCCAnalyses: Common problems and solutions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, CERN.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: flavours2025
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Branches</dt>
      <dd><a href="../../../main/index.html">main</a></dd>
      <dd><a href="../../../bnl2023/index.html">bnl2023</a></dd>
      <dd><a href="../../../cern2022/index.html">cern2022</a></dd>
      <dd><a href="Readme.html">flavours2025</a></dd>
      <dd><a href="../../../mit2024/index.html">mit2024</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>